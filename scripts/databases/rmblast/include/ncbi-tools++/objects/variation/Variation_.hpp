/* $Id$
 * ===========================================================================
 *
 *                            PUBLIC DOMAIN NOTICE
 *               National Center for Biotechnology Information
 *
 *  This software/database is a "United States Government Work" under the
 *  terms of the United States Copyright Act.  It was written as part of
 *  the author's official duties as a United States Government employee and
 *  thus cannot be copyrighted.  This software/database is freely available
 *  to the public for use. The National Library of Medicine and the U.S.
 *  Government have not placed any restriction on its use or reproduction.
 *
 *  Although all reasonable efforts have been taken to ensure the accuracy
 *  and reliability of the software and data, the NLM and the U.S.
 *  Government do not and cannot warrant the performance or results that
 *  may be obtained by using this software or data. The NLM and the U.S.
 *  Government disclaim all warranties, express or implied, including
 *  warranties of performance, merchantability or fitness for any particular
 *  purpose.
 *
 *  Please cite the author in any work or product based on this material.
 *
 * ===========================================================================
 *
 */

/// @file Variation_.hpp
/// Data storage class.
///
/// This file was generated by application DATATOOL
/// using the following specifications:
/// 'variation.asn'.
///
/// ATTENTION:
///   Don't edit or commit this file into CVS as this file will
///   be overridden (by DATATOOL) without warning!

#ifndef OBJECTS_VARIATION_VARIATION_BASE_HPP
#define OBJECTS_VARIATION_VARIATION_BASE_HPP

// standard includes
#include <serial/serialbase.hpp>

// generated includes
#include <list>
#include <string>

BEGIN_NCBI_SCOPE

#ifndef BEGIN_objects_SCOPE
#  define BEGIN_objects_SCOPE BEGIN_SCOPE(objects)
#  define END_objects_SCOPE END_SCOPE(objects)
#endif
BEGIN_objects_SCOPE // namespace ncbi::objects::


// forward declarations
class CBioseq;
class CDbtag;
class CObject_id;
class CPhenotype;
class CPopulation_data;
class CPub_set;
class CSubSource;
class CUser_object;
class CVariantPlacement;
class CVariantProperties;
class CVariation;
class CVariationException;
class CVariationMethod;
class CVariation_inst;


// generated classes

/////////////////////////////////////////////////////////////////////////////
class NCBI_VARIATION_EXPORT CVariation_Base : public CSerialObject
{
    typedef CSerialObject Tparent;
public:
    // constructor
    CVariation_Base(void);
    // destructor
    virtual ~CVariation_Base(void);

    // type info
    DECLARE_INTERNAL_TYPE_INFO();

    /////////////////////////////////////////////////////////////////////////////
    class NCBI_VARIATION_EXPORT C_Data : public CSerialObject
    {
        typedef CSerialObject Tparent;
    public:
        // constructor
        C_Data(void);
        // destructor
        ~C_Data(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        /////////////////////////////////////////////////////////////////////////////
        /// Set of related Variations.
        /// Location of the set equals to the union of member locations
        class NCBI_VARIATION_EXPORT C_Set : public CSerialObject
        {
            typedef CSerialObject Tparent;
        public:
            // constructor
            C_Set(void);
            // destructor
            ~C_Set(void);
        
            // type info
            DECLARE_INTERNAL_TYPE_INFO();
        
            enum EData_set_type {
                eData_set_type_unknown    =   0,
                eData_set_type_compound   =   1,  ///< complex change at the same location on the  same molecule
                eData_set_type_products   =   2,  ///< different products arising from the same  variation in a precursor, e.g. r.[13g>a,  13_88del]
                eData_set_type_haplotype  =   3,  ///< changes on the same allele, e.g  r.[13g>a;15u>c]
                eData_set_type_genotype   =   4,  ///< changes on different alleles in the same  genotype, e.g. g.[476C>T]+[476C>T]
                eData_set_type_mosaic     =   5,  ///< different genotypes in the same individual
                eData_set_type_individual =   6,  ///< same organism; allele relationship unknown,  e.g. g.[476C>T(+)183G>C]
                eData_set_type_population =   7,  ///< population
                eData_set_type_alleles    =   8,  ///< set represents a set of observed alleles
                eData_set_type_package    =   9,  ///< set represents a package of observations at  a given location, generally containing  asserted + reference
                eData_set_type_chimeric   =  10,  ///< e.g. c.[1C>T//2G>T]
                eData_set_type_other      = 255
            };
            
            /// Access to EData_set_type's attributes (values, names) as defined in spec
            static const NCBI_NS_NCBI::CEnumeratedTypeValues* ENUM_METHOD_NAME(EData_set_type)(void);
            
            // types
            typedef int TType;
            typedef list< CRef< CVariation > > TVariations;
            typedef string TName;
        
            // getters
            // setters
        
            /// mandatory
            /// typedef int TType
            ///  Check whether the Type data member has been assigned a value.
            bool IsSetType(void) const;
            /// Check whether it is safe or not to call GetType method.
            bool CanGetType(void) const;
            void ResetType(void);
            TType GetType(void) const;
            void SetType(TType value);
            TType& SetType(void);
        
            /// mandatory
            /// typedef list< CRef< CVariation > > TVariations
            ///  Check whether the Variations data member has been assigned a value.
            bool IsSetVariations(void) const;
            /// Check whether it is safe or not to call GetVariations method.
            bool CanGetVariations(void) const;
            void ResetVariations(void);
            const TVariations& GetVariations(void) const;
            TVariations& SetVariations(void);
        
            /// optional
            /// typedef string TName
            ///  Check whether the Name data member has been assigned a value.
            bool IsSetName(void) const;
            /// Check whether it is safe or not to call GetName method.
            bool CanGetName(void) const;
            void ResetName(void);
            const TName& GetName(void) const;
            void SetName(const TName& value);
            TName& SetName(void);
        
            /// Reset the whole object
            void Reset(void);
        
        
        private:
            // Prohibit copy constructor and assignment operator
            C_Set(const C_Set&);
            C_Set& operator=(const C_Set&);
        
            // data
            Uint4 m_set_State[1];
            int m_Type;
            list< CRef< CVariation > > m_Variations;
            string m_Name;
        };
    
        /// Choice variants.
        enum E_Choice {
            e_not_set = 0,         ///< No variant selected
            e_Unknown,
            e_Note,                ///<free-form
            e_Uniparental_disomy,
            e_Instance,            ///< actual sequence-edit at feat.location
            e_Set,
            e_Complex,             ///< variant is a complex and undescribed change at the location  This type of variant is known to occur in dbVar submissions
            e_Seq                  ///< Sequnece as it exists post-alteration
        };
        /// Maximum+1 value of the choice variant enumerator.
        enum E_ChoiceStopper {
            e_MaxChoice = 8 ///< == e_Seq+1
        };
    
        /// Reset the whole object
        void Reset(void);
    
        /// Reset the selection (set it to e_not_set).
        void ResetSelection(void);
    
        /// Which variant is currently selected.
        E_Choice Which(void) const;
    
        /// Verify selection, throw exception if it differs from the expected.
        void CheckSelected(E_Choice index) const;
    
        /// Throw 'InvalidSelection' exception.
        NCBI_NORETURN void ThrowInvalidSelection(E_Choice index) const;
    
        /// Retrieve selection name (for diagnostic purposes).
        static string SelectionName(E_Choice index);
    
        /// Select the requested variant if needed.
        void Select(E_Choice index, EResetVariant reset = eDoResetVariant);
        /// Select the requested variant if needed,
        /// allocating CObject variants from memory pool.
        void Select(E_Choice index,
                    EResetVariant reset,
                    CObjectMemoryPool* pool);
    
        // types
        typedef string TNote;
        typedef CVariation_inst TInstance;
        typedef C_Set TSet;
        typedef CBioseq TSeq;
    
        // getters
        // setters
    
    
        bool IsUnknown(void) const;
        void SetUnknown(void);
    
        // typedef string TNote
        bool IsNote(void) const;
        const TNote& GetNote(void) const;
        TNote& SetNote(void);
        void SetNote(const TNote& value);
    
    
        bool IsUniparental_disomy(void) const;
        void SetUniparental_disomy(void);
    
        // typedef CVariation_inst TInstance
        bool IsInstance(void) const;
        const TInstance& GetInstance(void) const;
        TInstance& SetInstance(void);
        void SetInstance(TInstance& value);
    
        // typedef C_Set TSet
        bool IsSet(void) const;
        const TSet& GetSet(void) const;
        TSet& SetSet(void);
        void SetSet(TSet& value);
    
    
        bool IsComplex(void) const;
        void SetComplex(void);
    
        // typedef CBioseq TSeq
        bool IsSeq(void) const;
        const TSeq& GetSeq(void) const;
        TSeq& SetSeq(void);
        void SetSeq(TSeq& value);
    
    
    private:
        // copy constructor and assignment operator
        C_Data(const C_Data& );
        C_Data& operator=(const C_Data& );
        // choice state
        E_Choice m_choice;
        // helper methods
        void DoSelect(E_Choice index, CObjectMemoryPool* pool = 0);
    
        static const char* const sm_SelectionNames[];
        // data
        union {
            NCBI_NS_NCBI::CUnionBuffer<NCBI_NS_STD::string> m_string;
            NCBI_NS_NCBI::CSerialObject *m_object;
        };
    };
    /////////////////////////////////////////////////////////////////////////////
    class NCBI_VARIATION_EXPORT C_E_Consequence : public CSerialObject
    {
        typedef CSerialObject Tparent;
    public:
        // constructor
        C_E_Consequence(void);
        // destructor
        ~C_E_Consequence(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        /////////////////////////////////////////////////////////////////////////////
        class NCBI_VARIATION_EXPORT C_Loss_of_heterozygosity : public CSerialObject
        {
            typedef CSerialObject Tparent;
        public:
            // constructor
            C_Loss_of_heterozygosity(void);
            // destructor
            ~C_Loss_of_heterozygosity(void);
        
            // type info
            DECLARE_INTERNAL_TYPE_INFO();
        
            // types
            typedef string TReference;
            typedef string TTest;
        
            // getters
            // setters
        
            /// In germline comparison, it will be reference genome assembly
            /// (default) or reference/normal population. In somatic mutation,
            /// it will be a name of the normal tissue.
            /// optional
            /// typedef string TReference
            ///  Check whether the Reference data member has been assigned a value.
            bool IsSetReference(void) const;
            /// Check whether it is safe or not to call GetReference method.
            bool CanGetReference(void) const;
            void ResetReference(void);
            const TReference& GetReference(void) const;
            void SetReference(const TReference& value);
            TReference& SetReference(void);
        
            /// Name of the testing subject type or the testing tissue.
            /// optional
            /// typedef string TTest
            ///  Check whether the Test data member has been assigned a value.
            bool IsSetTest(void) const;
            /// Check whether it is safe or not to call GetTest method.
            bool CanGetTest(void) const;
            void ResetTest(void);
            const TTest& GetTest(void) const;
            void SetTest(const TTest& value);
            TTest& SetTest(void);
        
            /// Reset the whole object
            void Reset(void);
        
        
        private:
            // Prohibit copy constructor and assignment operator
            C_Loss_of_heterozygosity(const C_Loss_of_heterozygosity&);
            C_Loss_of_heterozygosity& operator=(const C_Loss_of_heterozygosity&);
        
            // data
            Uint4 m_set_State[1];
            string m_Reference;
            string m_Test;
        };
    
        /// Choice variants.
        enum E_Choice {
            e_not_set = 0,             ///< No variant selected
            e_Unknown,
            e_Splicing,                ///<some effect on splicing
            e_Note,                    ///<freeform
            e_Variation,               ///< Describe resulting variation in the product, e.g. missense,  nonsense, silent, neutral, etc in a protein, that arises from  THIS variation.
            e_Loss_of_heterozygosity
        };
        /// Maximum+1 value of the choice variant enumerator.
        enum E_ChoiceStopper {
            e_MaxChoice = 6 ///< == e_Loss_of_heterozygosity+1
        };
    
        /// Reset the whole object
        void Reset(void);
    
        /// Reset the selection (set it to e_not_set).
        void ResetSelection(void);
    
        /// Which variant is currently selected.
        E_Choice Which(void) const;
    
        /// Verify selection, throw exception if it differs from the expected.
        void CheckSelected(E_Choice index) const;
    
        /// Throw 'InvalidSelection' exception.
        NCBI_NORETURN void ThrowInvalidSelection(E_Choice index) const;
    
        /// Retrieve selection name (for diagnostic purposes).
        static string SelectionName(E_Choice index);
    
        /// Select the requested variant if needed.
        void Select(E_Choice index, EResetVariant reset = eDoResetVariant);
        /// Select the requested variant if needed,
        /// allocating CObject variants from memory pool.
        void Select(E_Choice index,
                    EResetVariant reset,
                    CObjectMemoryPool* pool);
    
        // types
        typedef string TNote;
        typedef CVariation TVariation;
        typedef C_Loss_of_heterozygosity TLoss_of_heterozygosity;
    
        // getters
        // setters
    
    
        bool IsUnknown(void) const;
        void SetUnknown(void);
    
    
        bool IsSplicing(void) const;
        void SetSplicing(void);
    
        // typedef string TNote
        bool IsNote(void) const;
        const TNote& GetNote(void) const;
        TNote& SetNote(void);
        void SetNote(const TNote& value);
    
        // typedef CVariation TVariation
        bool IsVariation(void) const;
        const TVariation& GetVariation(void) const;
        TVariation& SetVariation(void);
        void SetVariation(TVariation& value);
    
        // typedef C_Loss_of_heterozygosity TLoss_of_heterozygosity
        bool IsLoss_of_heterozygosity(void) const;
        const TLoss_of_heterozygosity& GetLoss_of_heterozygosity(void) const;
        TLoss_of_heterozygosity& SetLoss_of_heterozygosity(void);
        void SetLoss_of_heterozygosity(TLoss_of_heterozygosity& value);
    
    
    private:
        // copy constructor and assignment operator
        C_E_Consequence(const C_E_Consequence& );
        C_E_Consequence& operator=(const C_E_Consequence& );
        // choice state
        E_Choice m_choice;
        // helper methods
        void DoSelect(E_Choice index, CObjectMemoryPool* pool = 0);
    
        static const char* const sm_SelectionNames[];
        // data
        union {
            NCBI_NS_NCBI::CUnionBuffer<NCBI_NS_STD::string> m_string;
            NCBI_NS_NCBI::CSerialObject *m_object;
        };
    };
    /////////////////////////////////////////////////////////////////////////////
    /// Frameshift-related info. Applies only to protein-level variations.
    /// see http://www.hgvs.org/mutnomen/recs-prot.html
    class NCBI_VARIATION_EXPORT C_Frameshift : public CSerialObject
    {
        typedef CSerialObject Tparent;
    public:
        // constructor
        C_Frameshift(void);
        // destructor
        ~C_Frameshift(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        // types
        typedef int TPhase;
        typedef int TX_length;
    
        // getters
        // setters
    
        /// optional
        /// typedef int TPhase
        ///  Check whether the Phase data member has been assigned a value.
        bool IsSetPhase(void) const;
        /// Check whether it is safe or not to call GetPhase method.
        bool CanGetPhase(void) const;
        void ResetPhase(void);
        TPhase GetPhase(void) const;
        void SetPhase(TPhase value);
        TPhase& SetPhase(void);
    
        /// optional
        /// typedef int TX_length
        ///  Check whether the X_length data member has been assigned a value.
        bool IsSetX_length(void) const;
        /// Check whether it is safe or not to call GetX_length method.
        bool CanGetX_length(void) const;
        void ResetX_length(void);
        TX_length GetX_length(void) const;
        void SetX_length(TX_length value);
        TX_length& SetX_length(void);
    
        /// Reset the whole object
        void Reset(void);
    
    
    private:
        // Prohibit copy constructor and assignment operator
        C_Frameshift(const C_Frameshift&);
        C_Frameshift& operator=(const C_Frameshift&);
    
        // data
        Uint4 m_set_State[1];
        int m_Phase;
        int m_X_length;
    };
    /////////////////////////////////////////////////////////////////////////////
    class NCBI_VARIATION_EXPORT C_E_Somatic_origin : public CSerialObject
    {
        typedef CSerialObject Tparent;
    public:
        // constructor
        C_E_Somatic_origin(void);
        // destructor
        ~C_E_Somatic_origin(void);
    
        // type info
        DECLARE_INTERNAL_TYPE_INFO();
    
        /////////////////////////////////////////////////////////////////////////////
        /// condition related to this origin's type
        class NCBI_VARIATION_EXPORT C_Condition : public CSerialObject
        {
            typedef CSerialObject Tparent;
        public:
            // constructor
            C_Condition(void);
            // destructor
            ~C_Condition(void);
        
            // type info
            DECLARE_INTERNAL_TYPE_INFO();
        
            // types
            typedef string TDescription;
            typedef list< CRef< CDbtag > > TObject_id;
        
            // getters
            // setters
        
            /// optional
            /// typedef string TDescription
            ///  Check whether the Description data member has been assigned a value.
            bool IsSetDescription(void) const;
            /// Check whether it is safe or not to call GetDescription method.
            bool CanGetDescription(void) const;
            void ResetDescription(void);
            const TDescription& GetDescription(void) const;
            void SetDescription(const TDescription& value);
            TDescription& SetDescription(void);
        
            /// reference to BioTerm / other descriptive database
            /// optional
            /// typedef list< CRef< CDbtag > > TObject_id
            ///  Check whether the Object_id data member has been assigned a value.
            bool IsSetObject_id(void) const;
            /// Check whether it is safe or not to call GetObject_id method.
            bool CanGetObject_id(void) const;
            void ResetObject_id(void);
            const TObject_id& GetObject_id(void) const;
            TObject_id& SetObject_id(void);
        
            /// Reset the whole object
            void Reset(void);
        
        
        private:
            // Prohibit copy constructor and assignment operator
            C_Condition(const C_Condition&);
            C_Condition& operator=(const C_Condition&);
        
            // data
            Uint4 m_set_State[1];
            string m_Description;
            list< CRef< CDbtag > > m_Object_id;
        };
        // types
        typedef CSubSource TSource;
        typedef C_Condition TCondition;
    
        // getters
        // setters
    
        /// description of the somatic origin itself
        /// optional
        /// typedef CSubSource TSource
        ///  Check whether the Source data member has been assigned a value.
        bool IsSetSource(void) const;
        /// Check whether it is safe or not to call GetSource method.
        bool CanGetSource(void) const;
        void ResetSource(void);
        const TSource& GetSource(void) const;
        void SetSource(TSource& value);
        TSource& SetSource(void);
    
        /// optional
        /// typedef C_Condition TCondition
        ///  Check whether the Condition data member has been assigned a value.
        bool IsSetCondition(void) const;
        /// Check whether it is safe or not to call GetCondition method.
        bool CanGetCondition(void) const;
        void ResetCondition(void);
        const TCondition& GetCondition(void) const;
        void SetCondition(TCondition& value);
        TCondition& SetCondition(void);
    
        /// Reset the whole object
        void Reset(void);
    
    
    private:
        // Prohibit copy constructor and assignment operator
        C_E_Somatic_origin(const C_E_Somatic_origin&);
        C_E_Somatic_origin& operator=(const C_E_Somatic_origin&);
    
        // data
        Uint4 m_set_State[1];
        CRef< TSource > m_Source;
        CRef< TCondition > m_Condition;
    };
    // types
    typedef CDbtag TId;
    typedef CDbtag TParent_id;
    typedef list< CRef< CObject_id > > TSample_id;
    typedef list< CRef< CDbtag > > TOther_ids;
    typedef string TName;
    typedef list< string > TSynonyms;
    typedef string TDescription;
    typedef list< CRef< CVariantPlacement > > TPlacements;
    typedef list< CRef< CPhenotype > > TPhenotype;
    typedef CVariationMethod TMethod;
    typedef list< CRef< CPopulation_data > > TPopulation_data;
    typedef CVariantProperties TVariant_prop;
    typedef CPub_set TPub;
    typedef CDbtag TClinical_test;
    typedef C_Data TData;
    typedef C_E_Consequence C_E;
    typedef list< CRef< C_E_Consequence > > TConsequence;
    typedef C_Frameshift TFrameshift;
    typedef list< CRef< CUser_object > > TExt;
    typedef list< CRef< C_E_Somatic_origin > > TSomatic_origin;
    typedef list< CRef< CVariationException > > TExceptions;
    typedef list< int > TSo_terms;

    // getters
    // setters

    /// ids (i.e., SNP rsid / ssid, dbVar nsv/nssv)
    /// expected values include 'dbSNP|rs12334', 'dbSNP|ss12345', 'dbVar|nsv1'
    ///
    /// we relate three kinds of IDs here:
    ///  - our current object's id
    ///  - the id of this object's parent, if it exists
    ///  - the sample ID that this item originates from
    /// optional
    /// typedef CDbtag TId
    ///  Check whether the Id data member has been assigned a value.
    bool IsSetId(void) const;
    /// Check whether it is safe or not to call GetId method.
    bool CanGetId(void) const;
    void ResetId(void);
    const TId& GetId(void) const;
    void SetId(TId& value);
    TId& SetId(void);

    /// optional
    /// typedef CDbtag TParent_id
    ///  Check whether the Parent_id data member has been assigned a value.
    bool IsSetParent_id(void) const;
    /// Check whether it is safe or not to call GetParent_id method.
    bool CanGetParent_id(void) const;
    void ResetParent_id(void);
    const TParent_id& GetParent_id(void) const;
    void SetParent_id(TParent_id& value);
    TParent_id& SetParent_id(void);

    /// optional
    /// typedef list< CRef< CObject_id > > TSample_id
    ///  Check whether the Sample_id data member has been assigned a value.
    bool IsSetSample_id(void) const;
    /// Check whether it is safe or not to call GetSample_id method.
    bool CanGetSample_id(void) const;
    void ResetSample_id(void);
    const TSample_id& GetSample_id(void) const;
    TSample_id& SetSample_id(void);

    /// optional
    /// typedef list< CRef< CDbtag > > TOther_ids
    ///  Check whether the Other_ids data member has been assigned a value.
    bool IsSetOther_ids(void) const;
    /// Check whether it is safe or not to call GetOther_ids method.
    bool CanGetOther_ids(void) const;
    void ResetOther_ids(void);
    const TOther_ids& GetOther_ids(void) const;
    TOther_ids& SetOther_ids(void);

    /// names and synonyms
    /// some variants have well-known canonical names and possible accepted
    /// synonyms
    /// optional
    /// typedef string TName
    ///  Check whether the Name data member has been assigned a value.
    bool IsSetName(void) const;
    /// Check whether it is safe or not to call GetName method.
    bool CanGetName(void) const;
    void ResetName(void);
    const TName& GetName(void) const;
    void SetName(const TName& value);
    TName& SetName(void);

    /// optional
    /// typedef list< string > TSynonyms
    ///  Check whether the Synonyms data member has been assigned a value.
    bool IsSetSynonyms(void) const;
    /// Check whether it is safe or not to call GetSynonyms method.
    bool CanGetSynonyms(void) const;
    void ResetSynonyms(void);
    const TSynonyms& GetSynonyms(void) const;
    TSynonyms& SetSynonyms(void);

    /// tag for comment and descriptions
    /// optional
    /// typedef string TDescription
    ///  Check whether the Description data member has been assigned a value.
    bool IsSetDescription(void) const;
    /// Check whether it is safe or not to call GetDescription method.
    bool CanGetDescription(void) const;
    void ResetDescription(void);
    const TDescription& GetDescription(void) const;
    void SetDescription(const TDescription& value);
    TDescription& SetDescription(void);

    /// where this beast is seen
    /// note that this is a set of locations, and there are no restrictions to
    /// the contents to this set. 
    /// optional
    /// typedef list< CRef< CVariantPlacement > > TPlacements
    ///  Check whether the Placements data member has been assigned a value.
    bool IsSetPlacements(void) const;
    /// Check whether it is safe or not to call GetPlacements method.
    bool CanGetPlacements(void) const;
    void ResetPlacements(void);
    const TPlacements& GetPlacements(void) const;
    TPlacements& SetPlacements(void);

    /// phenotype
    /// optional
    /// typedef list< CRef< CPhenotype > > TPhenotype
    ///  Check whether the Phenotype data member has been assigned a value.
    bool IsSetPhenotype(void) const;
    /// Check whether it is safe or not to call GetPhenotype method.
    bool CanGetPhenotype(void) const;
    void ResetPhenotype(void);
    const TPhenotype& GetPhenotype(void) const;
    TPhenotype& SetPhenotype(void);

    /// sequencing / acuisition method
    /// optional
    /// typedef CVariationMethod TMethod
    ///  Check whether the Method data member has been assigned a value.
    bool IsSetMethod(void) const;
    /// Check whether it is safe or not to call GetMethod method.
    bool CanGetMethod(void) const;
    void ResetMethod(void);
    const TMethod& GetMethod(void) const;
    void SetMethod(TMethod& value);
    TMethod& SetMethod(void);

    /// Note about SNP representation and pretinent fields: allele-frequency,
    /// population, quality-codes:
    /// The case of multiple alleles for a SNP would be described by
    /// parent-feature of type Variation-set.diff-alleles, where the child
    /// features of type Variation-inst, all at the same location, would
    /// describe individual alleles.
    /// population data
    /// optional
    /// typedef list< CRef< CPopulation_data > > TPopulation_data
    ///  Check whether the Population_data data member has been assigned a value.
    bool IsSetPopulation_data(void) const;
    /// Check whether it is safe or not to call GetPopulation_data method.
    bool CanGetPopulation_data(void) const;
    void ResetPopulation_data(void);
    const TPopulation_data& GetPopulation_data(void) const;
    TPopulation_data& SetPopulation_data(void);

    /// variant properties bit fields
    /// optional
    /// typedef CVariantProperties TVariant_prop
    ///  Check whether the Variant_prop data member has been assigned a value.
    bool IsSetVariant_prop(void) const;
    /// Check whether it is safe or not to call GetVariant_prop method.
    bool CanGetVariant_prop(void) const;
    void ResetVariant_prop(void);
    const TVariant_prop& GetVariant_prop(void) const;
    void SetVariant_prop(TVariant_prop& value);
    TVariant_prop& SetVariant_prop(void);

    /// publication support; same type as in seq-feat
    /// optional
    /// typedef CPub_set TPub
    ///  Check whether the Pub data member has been assigned a value.
    bool IsSetPub(void) const;
    /// Check whether it is safe or not to call GetPub method.
    bool CanGetPub(void) const;
    void ResetPub(void);
    const TPub& GetPub(void) const;
    void SetPub(TPub& value);
    TPub& SetPub(void);

    /// References to external 
    /// optional
    /// typedef CDbtag TClinical_test
    ///  Check whether the Clinical_test data member has been assigned a value.
    bool IsSetClinical_test(void) const;
    /// Check whether it is safe or not to call GetClinical_test method.
    bool CanGetClinical_test(void) const;
    void ResetClinical_test(void);
    const TClinical_test& GetClinical_test(void) const;
    void SetClinical_test(TClinical_test& value);
    TClinical_test& SetClinical_test(void);

    /// mandatory
    /// typedef C_Data TData
    ///  Check whether the Data data member has been assigned a value.
    bool IsSetData(void) const;
    /// Check whether it is safe or not to call GetData method.
    bool CanGetData(void) const;
    void ResetData(void);
    const TData& GetData(void) const;
    void SetData(TData& value);
    TData& SetData(void);

    /// optional
    /// typedef list< CRef< C_E_Consequence > > TConsequence
    ///  Check whether the Consequence data member has been assigned a value.
    bool IsSetConsequence(void) const;
    /// Check whether it is safe or not to call GetConsequence method.
    bool CanGetConsequence(void) const;
    void ResetConsequence(void);
    const TConsequence& GetConsequence(void) const;
    TConsequence& SetConsequence(void);

    /// optional
    /// typedef C_Frameshift TFrameshift
    ///  Check whether the Frameshift data member has been assigned a value.
    bool IsSetFrameshift(void) const;
    /// Check whether it is safe or not to call GetFrameshift method.
    bool CanGetFrameshift(void) const;
    void ResetFrameshift(void);
    const TFrameshift& GetFrameshift(void) const;
    void SetFrameshift(TFrameshift& value);
    TFrameshift& SetFrameshift(void);

    /// Additional undescribed extensions
    /// optional
    /// typedef list< CRef< CUser_object > > TExt
    ///  Check whether the Ext data member has been assigned a value.
    bool IsSetExt(void) const;
    /// Check whether it is safe or not to call GetExt method.
    bool CanGetExt(void) const;
    void ResetExt(void);
    const TExt& GetExt(void) const;
    TExt& SetExt(void);

    /// optional
    /// typedef list< CRef< C_E_Somatic_origin > > TSomatic_origin
    ///  Check whether the Somatic_origin data member has been assigned a value.
    bool IsSetSomatic_origin(void) const;
    /// Check whether it is safe or not to call GetSomatic_origin method.
    bool CanGetSomatic_origin(void) const;
    void ResetSomatic_origin(void);
    const TSomatic_origin& GetSomatic_origin(void) const;
    TSomatic_origin& SetSomatic_origin(void);

    /// optional
    /// typedef list< CRef< CVariationException > > TExceptions
    ///  Check whether the Exceptions data member has been assigned a value.
    bool IsSetExceptions(void) const;
    /// Check whether it is safe or not to call GetExceptions method.
    bool CanGetExceptions(void) const;
    void ResetExceptions(void);
    const TExceptions& GetExceptions(void) const;
    TExceptions& SetExceptions(void);

    /// optional
    /// typedef list< int > TSo_terms
    ///  Check whether the So_terms data member has been assigned a value.
    bool IsSetSo_terms(void) const;
    /// Check whether it is safe or not to call GetSo_terms method.
    bool CanGetSo_terms(void) const;
    void ResetSo_terms(void);
    const TSo_terms& GetSo_terms(void) const;
    TSo_terms& SetSo_terms(void);

    /// Reset the whole object
    virtual void Reset(void);


private:
    // Prohibit copy constructor and assignment operator
    CVariation_Base(const CVariation_Base&);
    CVariation_Base& operator=(const CVariation_Base&);

    // data
    Uint4 m_set_State[2];
    CRef< TId > m_Id;
    CRef< TParent_id > m_Parent_id;
    list< CRef< CObject_id > > m_Sample_id;
    list< CRef< CDbtag > > m_Other_ids;
    string m_Name;
    list< string > m_Synonyms;
    string m_Description;
    list< CRef< CVariantPlacement > > m_Placements;
    list< CRef< CPhenotype > > m_Phenotype;
    CRef< TMethod > m_Method;
    list< CRef< CPopulation_data > > m_Population_data;
    CRef< TVariant_prop > m_Variant_prop;
    CRef< TPub > m_Pub;
    CRef< TClinical_test > m_Clinical_test;
    CRef< TData > m_Data;
    list< CRef< C_E_Consequence > > m_Consequence;
    CRef< TFrameshift > m_Frameshift;
    list< CRef< CUser_object > > m_Ext;
    list< CRef< C_E_Somatic_origin > > m_Somatic_origin;
    list< CRef< CVariationException > > m_Exceptions;
    list< int > m_So_terms;
};






///////////////////////////////////////////////////////////
///////////////////// inline methods //////////////////////
///////////////////////////////////////////////////////////
inline
bool CVariation_Base::C_Data::C_Set::IsSetType(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CVariation_Base::C_Data::C_Set::CanGetType(void) const
{
    return IsSetType();
}

inline
void CVariation_Base::C_Data::C_Set::ResetType(void)
{
    m_Type = (EData_set_type)(0);
    m_set_State[0] &= ~0x3;
}

inline
CVariation_Base::C_Data::C_Set::TType CVariation_Base::C_Data::C_Set::GetType(void) const
{
    if (!CanGetType()) {
        ThrowUnassigned(0);
    }
    return m_Type;
}

inline
void CVariation_Base::C_Data::C_Set::SetType(CVariation_Base::C_Data::C_Set::TType value)
{
    m_Type = value;
    m_set_State[0] |= 0x3;
}

inline
CVariation_Base::C_Data::C_Set::TType& CVariation_Base::C_Data::C_Set::SetType(void)
{
#ifdef _DEBUG
    if (!IsSetType()) {
        memset(&m_Type,UnassignedByte(),sizeof(m_Type));
    }
#endif
    m_set_State[0] |= 0x1;
    return m_Type;
}

inline
bool CVariation_Base::C_Data::C_Set::IsSetVariations(void) const
{
    return ((m_set_State[0] & 0xc) != 0);
}

inline
bool CVariation_Base::C_Data::C_Set::CanGetVariations(void) const
{
    return true;
}

inline
const CVariation_Base::C_Data::C_Set::TVariations& CVariation_Base::C_Data::C_Set::GetVariations(void) const
{
    return m_Variations;
}

inline
CVariation_Base::C_Data::C_Set::TVariations& CVariation_Base::C_Data::C_Set::SetVariations(void)
{
    m_set_State[0] |= 0x4;
    return m_Variations;
}

inline
bool CVariation_Base::C_Data::C_Set::IsSetName(void) const
{
    return ((m_set_State[0] & 0x30) != 0);
}

inline
bool CVariation_Base::C_Data::C_Set::CanGetName(void) const
{
    return IsSetName();
}

inline
const CVariation_Base::C_Data::C_Set::TName& CVariation_Base::C_Data::C_Set::GetName(void) const
{
    if (!CanGetName()) {
        ThrowUnassigned(2);
    }
    return m_Name;
}

inline
void CVariation_Base::C_Data::C_Set::SetName(const CVariation_Base::C_Data::C_Set::TName& value)
{
    m_Name = value;
    m_set_State[0] |= 0x30;
}

inline
CVariation_Base::C_Data::C_Set::TName& CVariation_Base::C_Data::C_Set::SetName(void)
{
#ifdef _DEBUG
    if (!IsSetName()) {
        m_Name = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x10;
    return m_Name;
}

inline
CVariation_Base::C_Data::E_Choice CVariation_Base::C_Data::Which(void) const
{
    return m_choice;
}

inline
void CVariation_Base::C_Data::CheckSelected(E_Choice index) const
{
    if ( m_choice != index )
        ThrowInvalidSelection(index);
}

inline
void CVariation_Base::C_Data::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    if ( reset == NCBI_NS_NCBI::eDoResetVariant || m_choice != index ) {
        if ( m_choice != e_not_set )
            ResetSelection();
        DoSelect(index, pool);
    }
}

inline
void CVariation_Base::C_Data::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset)
{
    Select(index, reset, 0);
}

inline
bool CVariation_Base::C_Data::IsUnknown(void) const
{
    return m_choice == e_Unknown;
}

inline
void CVariation_Base::C_Data::SetUnknown(void)
{
    Select(e_Unknown, NCBI_NS_NCBI::eDoNotResetVariant);
}

inline
bool CVariation_Base::C_Data::IsNote(void) const
{
    return m_choice == e_Note;
}

inline
const CVariation_Base::C_Data::TNote& CVariation_Base::C_Data::GetNote(void) const
{
    CheckSelected(e_Note);
    return *m_string;
}

inline
CVariation_Base::C_Data::TNote& CVariation_Base::C_Data::SetNote(void)
{
    Select(e_Note, NCBI_NS_NCBI::eDoNotResetVariant);
    return *m_string;
}

inline
bool CVariation_Base::C_Data::IsUniparental_disomy(void) const
{
    return m_choice == e_Uniparental_disomy;
}

inline
void CVariation_Base::C_Data::SetUniparental_disomy(void)
{
    Select(e_Uniparental_disomy, NCBI_NS_NCBI::eDoNotResetVariant);
}

inline
bool CVariation_Base::C_Data::IsInstance(void) const
{
    return m_choice == e_Instance;
}

inline
bool CVariation_Base::C_Data::IsSet(void) const
{
    return m_choice == e_Set;
}

inline
bool CVariation_Base::C_Data::IsComplex(void) const
{
    return m_choice == e_Complex;
}

inline
void CVariation_Base::C_Data::SetComplex(void)
{
    Select(e_Complex, NCBI_NS_NCBI::eDoNotResetVariant);
}

inline
bool CVariation_Base::C_Data::IsSeq(void) const
{
    return m_choice == e_Seq;
}

inline
bool CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::IsSetReference(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::CanGetReference(void) const
{
    return IsSetReference();
}

inline
const CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TReference& CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::GetReference(void) const
{
    if (!CanGetReference()) {
        ThrowUnassigned(0);
    }
    return m_Reference;
}

inline
void CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::SetReference(const CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TReference& value)
{
    m_Reference = value;
    m_set_State[0] |= 0x3;
}

inline
CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TReference& CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::SetReference(void)
{
#ifdef _DEBUG
    if (!IsSetReference()) {
        m_Reference = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x1;
    return m_Reference;
}

inline
bool CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::IsSetTest(void) const
{
    return ((m_set_State[0] & 0xc) != 0);
}

inline
bool CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::CanGetTest(void) const
{
    return IsSetTest();
}

inline
const CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TTest& CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::GetTest(void) const
{
    if (!CanGetTest()) {
        ThrowUnassigned(1);
    }
    return m_Test;
}

inline
void CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::SetTest(const CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TTest& value)
{
    m_Test = value;
    m_set_State[0] |= 0xc;
}

inline
CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::TTest& CVariation_Base::C_E_Consequence::C_Loss_of_heterozygosity::SetTest(void)
{
#ifdef _DEBUG
    if (!IsSetTest()) {
        m_Test = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x4;
    return m_Test;
}

inline
CVariation_Base::C_E_Consequence::E_Choice CVariation_Base::C_E_Consequence::Which(void) const
{
    return m_choice;
}

inline
void CVariation_Base::C_E_Consequence::CheckSelected(E_Choice index) const
{
    if ( m_choice != index )
        ThrowInvalidSelection(index);
}

inline
void CVariation_Base::C_E_Consequence::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset, NCBI_NS_NCBI::CObjectMemoryPool* pool)
{
    if ( reset == NCBI_NS_NCBI::eDoResetVariant || m_choice != index ) {
        if ( m_choice != e_not_set )
            ResetSelection();
        DoSelect(index, pool);
    }
}

inline
void CVariation_Base::C_E_Consequence::Select(E_Choice index, NCBI_NS_NCBI::EResetVariant reset)
{
    Select(index, reset, 0);
}

inline
bool CVariation_Base::C_E_Consequence::IsUnknown(void) const
{
    return m_choice == e_Unknown;
}

inline
void CVariation_Base::C_E_Consequence::SetUnknown(void)
{
    Select(e_Unknown, NCBI_NS_NCBI::eDoNotResetVariant);
}

inline
bool CVariation_Base::C_E_Consequence::IsSplicing(void) const
{
    return m_choice == e_Splicing;
}

inline
void CVariation_Base::C_E_Consequence::SetSplicing(void)
{
    Select(e_Splicing, NCBI_NS_NCBI::eDoNotResetVariant);
}

inline
bool CVariation_Base::C_E_Consequence::IsNote(void) const
{
    return m_choice == e_Note;
}

inline
const CVariation_Base::C_E_Consequence::TNote& CVariation_Base::C_E_Consequence::GetNote(void) const
{
    CheckSelected(e_Note);
    return *m_string;
}

inline
CVariation_Base::C_E_Consequence::TNote& CVariation_Base::C_E_Consequence::SetNote(void)
{
    Select(e_Note, NCBI_NS_NCBI::eDoNotResetVariant);
    return *m_string;
}

inline
bool CVariation_Base::C_E_Consequence::IsVariation(void) const
{
    return m_choice == e_Variation;
}

inline
bool CVariation_Base::C_E_Consequence::IsLoss_of_heterozygosity(void) const
{
    return m_choice == e_Loss_of_heterozygosity;
}

inline
bool CVariation_Base::C_Frameshift::IsSetPhase(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CVariation_Base::C_Frameshift::CanGetPhase(void) const
{
    return IsSetPhase();
}

inline
void CVariation_Base::C_Frameshift::ResetPhase(void)
{
    m_Phase = 0;
    m_set_State[0] &= ~0x3;
}

inline
CVariation_Base::C_Frameshift::TPhase CVariation_Base::C_Frameshift::GetPhase(void) const
{
    if (!CanGetPhase()) {
        ThrowUnassigned(0);
    }
    return m_Phase;
}

inline
void CVariation_Base::C_Frameshift::SetPhase(CVariation_Base::C_Frameshift::TPhase value)
{
    m_Phase = value;
    m_set_State[0] |= 0x3;
}

inline
CVariation_Base::C_Frameshift::TPhase& CVariation_Base::C_Frameshift::SetPhase(void)
{
#ifdef _DEBUG
    if (!IsSetPhase()) {
        memset(&m_Phase,UnassignedByte(),sizeof(m_Phase));
    }
#endif
    m_set_State[0] |= 0x1;
    return m_Phase;
}

inline
bool CVariation_Base::C_Frameshift::IsSetX_length(void) const
{
    return ((m_set_State[0] & 0xc) != 0);
}

inline
bool CVariation_Base::C_Frameshift::CanGetX_length(void) const
{
    return IsSetX_length();
}

inline
void CVariation_Base::C_Frameshift::ResetX_length(void)
{
    m_X_length = 0;
    m_set_State[0] &= ~0xc;
}

inline
CVariation_Base::C_Frameshift::TX_length CVariation_Base::C_Frameshift::GetX_length(void) const
{
    if (!CanGetX_length()) {
        ThrowUnassigned(1);
    }
    return m_X_length;
}

inline
void CVariation_Base::C_Frameshift::SetX_length(CVariation_Base::C_Frameshift::TX_length value)
{
    m_X_length = value;
    m_set_State[0] |= 0xc;
}

inline
CVariation_Base::C_Frameshift::TX_length& CVariation_Base::C_Frameshift::SetX_length(void)
{
#ifdef _DEBUG
    if (!IsSetX_length()) {
        memset(&m_X_length,UnassignedByte(),sizeof(m_X_length));
    }
#endif
    m_set_State[0] |= 0x4;
    return m_X_length;
}

inline
bool CVariation_Base::C_E_Somatic_origin::C_Condition::IsSetDescription(void) const
{
    return ((m_set_State[0] & 0x3) != 0);
}

inline
bool CVariation_Base::C_E_Somatic_origin::C_Condition::CanGetDescription(void) const
{
    return IsSetDescription();
}

inline
const CVariation_Base::C_E_Somatic_origin::C_Condition::TDescription& CVariation_Base::C_E_Somatic_origin::C_Condition::GetDescription(void) const
{
    if (!CanGetDescription()) {
        ThrowUnassigned(0);
    }
    return m_Description;
}

inline
void CVariation_Base::C_E_Somatic_origin::C_Condition::SetDescription(const CVariation_Base::C_E_Somatic_origin::C_Condition::TDescription& value)
{
    m_Description = value;
    m_set_State[0] |= 0x3;
}

inline
CVariation_Base::C_E_Somatic_origin::C_Condition::TDescription& CVariation_Base::C_E_Somatic_origin::C_Condition::SetDescription(void)
{
#ifdef _DEBUG
    if (!IsSetDescription()) {
        m_Description = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x1;
    return m_Description;
}

inline
bool CVariation_Base::C_E_Somatic_origin::C_Condition::IsSetObject_id(void) const
{
    return ((m_set_State[0] & 0xc) != 0);
}

inline
bool CVariation_Base::C_E_Somatic_origin::C_Condition::CanGetObject_id(void) const
{
    return true;
}

inline
const CVariation_Base::C_E_Somatic_origin::C_Condition::TObject_id& CVariation_Base::C_E_Somatic_origin::C_Condition::GetObject_id(void) const
{
    return m_Object_id;
}

inline
CVariation_Base::C_E_Somatic_origin::C_Condition::TObject_id& CVariation_Base::C_E_Somatic_origin::C_Condition::SetObject_id(void)
{
    m_set_State[0] |= 0x4;
    return m_Object_id;
}

inline
bool CVariation_Base::C_E_Somatic_origin::IsSetSource(void) const
{
    return m_Source.NotEmpty();
}

inline
bool CVariation_Base::C_E_Somatic_origin::CanGetSource(void) const
{
    return IsSetSource();
}

inline
const CVariation_Base::C_E_Somatic_origin::TSource& CVariation_Base::C_E_Somatic_origin::GetSource(void) const
{
    if (!CanGetSource()) {
        ThrowUnassigned(0);
    }
    return (*m_Source);
}

inline
bool CVariation_Base::C_E_Somatic_origin::IsSetCondition(void) const
{
    return m_Condition.NotEmpty();
}

inline
bool CVariation_Base::C_E_Somatic_origin::CanGetCondition(void) const
{
    return IsSetCondition();
}

inline
const CVariation_Base::C_E_Somatic_origin::TCondition& CVariation_Base::C_E_Somatic_origin::GetCondition(void) const
{
    if (!CanGetCondition()) {
        ThrowUnassigned(1);
    }
    return (*m_Condition);
}

inline
bool CVariation_Base::IsSetId(void) const
{
    return m_Id.NotEmpty();
}

inline
bool CVariation_Base::CanGetId(void) const
{
    return IsSetId();
}

inline
const CVariation_Base::TId& CVariation_Base::GetId(void) const
{
    if (!CanGetId()) {
        ThrowUnassigned(0);
    }
    return (*m_Id);
}

inline
bool CVariation_Base::IsSetParent_id(void) const
{
    return m_Parent_id.NotEmpty();
}

inline
bool CVariation_Base::CanGetParent_id(void) const
{
    return IsSetParent_id();
}

inline
const CVariation_Base::TParent_id& CVariation_Base::GetParent_id(void) const
{
    if (!CanGetParent_id()) {
        ThrowUnassigned(1);
    }
    return (*m_Parent_id);
}

inline
bool CVariation_Base::IsSetSample_id(void) const
{
    return ((m_set_State[0] & 0x30) != 0);
}

inline
bool CVariation_Base::CanGetSample_id(void) const
{
    return true;
}

inline
const CVariation_Base::TSample_id& CVariation_Base::GetSample_id(void) const
{
    return m_Sample_id;
}

inline
CVariation_Base::TSample_id& CVariation_Base::SetSample_id(void)
{
    m_set_State[0] |= 0x10;
    return m_Sample_id;
}

inline
bool CVariation_Base::IsSetOther_ids(void) const
{
    return ((m_set_State[0] & 0xc0) != 0);
}

inline
bool CVariation_Base::CanGetOther_ids(void) const
{
    return true;
}

inline
const CVariation_Base::TOther_ids& CVariation_Base::GetOther_ids(void) const
{
    return m_Other_ids;
}

inline
CVariation_Base::TOther_ids& CVariation_Base::SetOther_ids(void)
{
    m_set_State[0] |= 0x40;
    return m_Other_ids;
}

inline
bool CVariation_Base::IsSetName(void) const
{
    return ((m_set_State[0] & 0x300) != 0);
}

inline
bool CVariation_Base::CanGetName(void) const
{
    return IsSetName();
}

inline
const CVariation_Base::TName& CVariation_Base::GetName(void) const
{
    if (!CanGetName()) {
        ThrowUnassigned(4);
    }
    return m_Name;
}

inline
void CVariation_Base::SetName(const CVariation_Base::TName& value)
{
    m_Name = value;
    m_set_State[0] |= 0x300;
}

inline
CVariation_Base::TName& CVariation_Base::SetName(void)
{
#ifdef _DEBUG
    if (!IsSetName()) {
        m_Name = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x100;
    return m_Name;
}

inline
bool CVariation_Base::IsSetSynonyms(void) const
{
    return ((m_set_State[0] & 0xc00) != 0);
}

inline
bool CVariation_Base::CanGetSynonyms(void) const
{
    return true;
}

inline
const CVariation_Base::TSynonyms& CVariation_Base::GetSynonyms(void) const
{
    return m_Synonyms;
}

inline
CVariation_Base::TSynonyms& CVariation_Base::SetSynonyms(void)
{
    m_set_State[0] |= 0x400;
    return m_Synonyms;
}

inline
bool CVariation_Base::IsSetDescription(void) const
{
    return ((m_set_State[0] & 0x3000) != 0);
}

inline
bool CVariation_Base::CanGetDescription(void) const
{
    return IsSetDescription();
}

inline
const CVariation_Base::TDescription& CVariation_Base::GetDescription(void) const
{
    if (!CanGetDescription()) {
        ThrowUnassigned(6);
    }
    return m_Description;
}

inline
void CVariation_Base::SetDescription(const CVariation_Base::TDescription& value)
{
    m_Description = value;
    m_set_State[0] |= 0x3000;
}

inline
CVariation_Base::TDescription& CVariation_Base::SetDescription(void)
{
#ifdef _DEBUG
    if (!IsSetDescription()) {
        m_Description = UnassignedString();
    }
#endif
    m_set_State[0] |= 0x1000;
    return m_Description;
}

inline
bool CVariation_Base::IsSetPlacements(void) const
{
    return ((m_set_State[0] & 0xc000) != 0);
}

inline
bool CVariation_Base::CanGetPlacements(void) const
{
    return true;
}

inline
const CVariation_Base::TPlacements& CVariation_Base::GetPlacements(void) const
{
    return m_Placements;
}

inline
CVariation_Base::TPlacements& CVariation_Base::SetPlacements(void)
{
    m_set_State[0] |= 0x4000;
    return m_Placements;
}

inline
bool CVariation_Base::IsSetPhenotype(void) const
{
    return ((m_set_State[0] & 0x30000) != 0);
}

inline
bool CVariation_Base::CanGetPhenotype(void) const
{
    return true;
}

inline
const CVariation_Base::TPhenotype& CVariation_Base::GetPhenotype(void) const
{
    return m_Phenotype;
}

inline
CVariation_Base::TPhenotype& CVariation_Base::SetPhenotype(void)
{
    m_set_State[0] |= 0x10000;
    return m_Phenotype;
}

inline
bool CVariation_Base::IsSetMethod(void) const
{
    return m_Method.NotEmpty();
}

inline
bool CVariation_Base::CanGetMethod(void) const
{
    return IsSetMethod();
}

inline
const CVariation_Base::TMethod& CVariation_Base::GetMethod(void) const
{
    if (!CanGetMethod()) {
        ThrowUnassigned(9);
    }
    return (*m_Method);
}

inline
bool CVariation_Base::IsSetPopulation_data(void) const
{
    return ((m_set_State[0] & 0x300000) != 0);
}

inline
bool CVariation_Base::CanGetPopulation_data(void) const
{
    return true;
}

inline
const CVariation_Base::TPopulation_data& CVariation_Base::GetPopulation_data(void) const
{
    return m_Population_data;
}

inline
CVariation_Base::TPopulation_data& CVariation_Base::SetPopulation_data(void)
{
    m_set_State[0] |= 0x100000;
    return m_Population_data;
}

inline
bool CVariation_Base::IsSetVariant_prop(void) const
{
    return m_Variant_prop.NotEmpty();
}

inline
bool CVariation_Base::CanGetVariant_prop(void) const
{
    return IsSetVariant_prop();
}

inline
const CVariation_Base::TVariant_prop& CVariation_Base::GetVariant_prop(void) const
{
    if (!CanGetVariant_prop()) {
        ThrowUnassigned(11);
    }
    return (*m_Variant_prop);
}

inline
bool CVariation_Base::IsSetPub(void) const
{
    return m_Pub.NotEmpty();
}

inline
bool CVariation_Base::CanGetPub(void) const
{
    return IsSetPub();
}

inline
const CVariation_Base::TPub& CVariation_Base::GetPub(void) const
{
    if (!CanGetPub()) {
        ThrowUnassigned(12);
    }
    return (*m_Pub);
}

inline
bool CVariation_Base::IsSetClinical_test(void) const
{
    return m_Clinical_test.NotEmpty();
}

inline
bool CVariation_Base::CanGetClinical_test(void) const
{
    return IsSetClinical_test();
}

inline
const CVariation_Base::TClinical_test& CVariation_Base::GetClinical_test(void) const
{
    if (!CanGetClinical_test()) {
        ThrowUnassigned(13);
    }
    return (*m_Clinical_test);
}

inline
bool CVariation_Base::IsSetData(void) const
{
    return m_Data.NotEmpty();
}

inline
bool CVariation_Base::CanGetData(void) const
{
    return true;
}

inline
const CVariation_Base::TData& CVariation_Base::GetData(void) const
{
    if ( !m_Data ) {
        const_cast<CVariation_Base*>(this)->ResetData();
    }
    return (*m_Data);
}

inline
CVariation_Base::TData& CVariation_Base::SetData(void)
{
    if ( !m_Data ) {
        ResetData();
    }
    return (*m_Data);
}

inline
bool CVariation_Base::IsSetConsequence(void) const
{
    return ((m_set_State[0] & 0xc0000000) != 0);
}

inline
bool CVariation_Base::CanGetConsequence(void) const
{
    return true;
}

inline
const CVariation_Base::TConsequence& CVariation_Base::GetConsequence(void) const
{
    return m_Consequence;
}

inline
CVariation_Base::TConsequence& CVariation_Base::SetConsequence(void)
{
    m_set_State[0] |= 0x40000000;
    return m_Consequence;
}

inline
bool CVariation_Base::IsSetFrameshift(void) const
{
    return m_Frameshift.NotEmpty();
}

inline
bool CVariation_Base::CanGetFrameshift(void) const
{
    return IsSetFrameshift();
}

inline
const CVariation_Base::TFrameshift& CVariation_Base::GetFrameshift(void) const
{
    if (!CanGetFrameshift()) {
        ThrowUnassigned(16);
    }
    return (*m_Frameshift);
}

inline
bool CVariation_Base::IsSetExt(void) const
{
    return ((m_set_State[1] & 0xc) != 0);
}

inline
bool CVariation_Base::CanGetExt(void) const
{
    return true;
}

inline
const CVariation_Base::TExt& CVariation_Base::GetExt(void) const
{
    return m_Ext;
}

inline
CVariation_Base::TExt& CVariation_Base::SetExt(void)
{
    m_set_State[1] |= 0x4;
    return m_Ext;
}

inline
bool CVariation_Base::IsSetSomatic_origin(void) const
{
    return ((m_set_State[1] & 0x30) != 0);
}

inline
bool CVariation_Base::CanGetSomatic_origin(void) const
{
    return true;
}

inline
const CVariation_Base::TSomatic_origin& CVariation_Base::GetSomatic_origin(void) const
{
    return m_Somatic_origin;
}

inline
CVariation_Base::TSomatic_origin& CVariation_Base::SetSomatic_origin(void)
{
    m_set_State[1] |= 0x10;
    return m_Somatic_origin;
}

inline
bool CVariation_Base::IsSetExceptions(void) const
{
    return ((m_set_State[1] & 0xc0) != 0);
}

inline
bool CVariation_Base::CanGetExceptions(void) const
{
    return true;
}

inline
const CVariation_Base::TExceptions& CVariation_Base::GetExceptions(void) const
{
    return m_Exceptions;
}

inline
CVariation_Base::TExceptions& CVariation_Base::SetExceptions(void)
{
    m_set_State[1] |= 0x40;
    return m_Exceptions;
}

inline
bool CVariation_Base::IsSetSo_terms(void) const
{
    return ((m_set_State[1] & 0x300) != 0);
}

inline
bool CVariation_Base::CanGetSo_terms(void) const
{
    return true;
}

inline
const CVariation_Base::TSo_terms& CVariation_Base::GetSo_terms(void) const
{
    return m_So_terms;
}

inline
CVariation_Base::TSo_terms& CVariation_Base::SetSo_terms(void)
{
    m_set_State[1] |= 0x100;
    return m_So_terms;
}

///////////////////////////////////////////////////////////
////////////////// end of inline methods //////////////////
///////////////////////////////////////////////////////////





END_objects_SCOPE // namespace ncbi::objects::

END_NCBI_SCOPE


#endif // OBJECTS_VARIATION_VARIATION_BASE_HPP
